---
title: "Appropriation des données"
subtitle: "Histogramme des distances au transect et fonction de détection"
author: "Léa Pautrel"
output:
  html_document:
    highlight: zenburn
    number_sections: yes
    theme: yeti
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	error = TRUE
)

# Packages
library(dplyr)				# tidyverse
library(foreign)			# read.dbf
library(DT)						# interactive HTML datatables

## Graphes packages
library(ggplot2) ; ggplot2::theme_set(theme_light())
library(ggmap)
library(wesanderson)
library(ggpubr)
library(plotly)
library(cowplot)

## Packages calcul
library(Rdistance)
```

------------------------------------

# Importation des données
```{r import_donnees}
load("../data/effort_output.RData")
# effort_ouput : Effort data divided in multiple sub-data differing by their scale of study.

load("../data/list_prepare_obs_by_sp.RData")
# list_prepare_obs_by_sp : observation data divided in multiple sub-data differing by their scale of study.

load("../data/predata_output.RData")
# predata_output : A grid of 2km cells size with different covariable associated around the observation.

gridata <- read.dbf("../data/SPEE_CAPECET_Grid2km_modified.dbf")
# gridata : equivalent to predata from predata_output but with a extended surface
```

# Distances au transect
## Histogramme : comptage
```{r fig.height = 4}
list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata %>% 
  ggplot(aes(x = distance)) +
  geom_histogram(bins = 15, col = "white")
```

## Histogramme : densité
```{r fig.height = 4}
list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata %>%
	gghistogram(
		x = "distance",
		y = "..density..",
		bins = 15,
		add = "mean",
		rug = TRUE,
		fill = "blue",
		col = "darkblue",
		add_density = TRUE
	)
```

## Calcul de la fonction de détection : sans covariables

```{r fig.width=10}
obsdata <- list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata
```

### Comparaison des effets des différentes loi pour la vraisemblance

Création d'une fonction `compare_loi_vrais` qui prend en arguments le tableau de données et la formula (`distance ~ 1` ou `distance ~ covar1 + covar2`), et renvoie un graphique qui compare les 5 lois de distributions disponibles pour la vraisemblance.

Remarque : pointSurvey = FALSE car transects
```{r fig.width=10, include=FALSE}
compare_loi_vrais <- function(tableau, formula){
	
	dfunc1 <- Rdistance::dfuncEstim(
		formula = formula,
		detectionData = tableau,
		siteData = tableau,
		likelihood = "uniform",
		w.hi = 0.3
	)
	
	dfunc2 <- Rdistance::dfuncEstim(
		formula = formula,
		detectionData = tableau,
		siteData = tableau,
		likelihood = "halfnorm",
		w.hi = 0.3
	)
	
	
	dfunc3 <- Rdistance::dfuncEstim(
		formula = formula,
		detectionData = tableau,
		siteData = tableau,
		likelihood = "hazrate",
		w.hi = 0.3
	)
	
	
	dfunc4 <- Rdistance::dfuncEstim(
		formula = formula,
		detectionData = tableau,
		siteData = tableau,
		likelihood = "negexp",
		w.hi = 0.3
	)
	
	
	dfunc5 <- Rdistance::dfuncEstim(
		formula = formula,
		detectionData = tableau,
		siteData = tableau,
		likelihood = "Gamma",
		w.hi = 0.3
	)
	
	par(mfrow = c(2, 3))
	plot(dfunc1)
	plot(dfunc2)
	plot(dfunc3)
	plot(dfunc4)
	plot(dfunc5)
}
```

Sans covariables, on obtient ceci :

```{r fig.width=10}
compare_loi_vrais(tableau = list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata[,c(1,3)],
									formula = "distance ~ 1")
```

## Fonction de détection : ajout des covariables

```{r, echo = TRUE}
head(obsdata[,c(3,5,6)])
```

Dans obsdata, on a aussi les segments de transect `Seg` et le `Sample.Label`. On pourra donc lier les données obs et les données covariables sur l'une de ces variables.
```{r, echo = TRUE}
cov_segment <- predata_output$segdata
dim(cov_segment)
head(cov_segment[, c(3,5,4)])
```

On va alors pouvoir récupérer plusieurs covariables intéressantes :

```{r}
cov_segment[1:3,15:23] %>% as_tibble()
```

* La profondeur `depth`
* La distance par rapport à la côte `distCoast`
* ?? `dist200`
* La pente `slopeP`
* ?? `CHL_4w_mea` `CHL_4w_sd`  `SST_4w_mea` `SST_4w_sd`  `POC_4w_mea`

### Manipulation des données : création d'une table avec les observations et les covariables

**Quelle est la clé unique de cov_segment ? Seg ou Sample.Label ?**

```{r, echo = TRUE}
nrow(cov_segment)
nrow(distinct(cov_segment, Seg))
nrow(distinct(cov_segment, Sample.Label))
```

Il s'agit de Seg. On va donc joindre sur Seg. On obtient le tableau suivant

```{r}
# Jointure
obs_cov_sample <- dplyr::left_join(obsdata, cov_segment, by = "Seg")

# Réarrangement des colonnes
obs_cov_sample <- obs_cov_sample[, c(3, 5:11, 1:2, 14:31)]
colnames(obs_cov_sample)[1] = "Transect.Label"
colnames(obs_cov_sample)[2] = "Seg"

# Affichages
DT::datatable(obs_cov_sample)
```

### Comparaison des fonctions de détection selon les lois pour la vraisemblance

D'abord, on va prendre en compte seulement quelques covariables pour voir l'effet qu'elles ont : la profondeur `depth` ; la distance par rapport à la côte `distCoat` et la pente `slopeP`.


#### Test avec les données du package

```{r}
# Importation des données
data(sparrowDetectionData)
data(sparrowSiteData)

# Estimation de la fonction de détection
sparrow_dfuncObs <- dfuncEstim(
	formula = dist ~ observer,
	detectionData = sparrowDetectionData,
	siteData = sparrowSiteData,
	likelihood = "halfnorm",
	w.hi = 100,
	pointSurvey = FALSE,
	control = RdistanceControls(maxIter = 1000)
)

# Affichage
plot(sparrow_dfuncObs,
		 newdata = data.frame(observer = levels(sparrowSiteData$observer)))
```

#### Test en fonction de la profondeur
Initialisation
```{r echo=TRUE}
formula <- "distance ~ depth"
sharkDetectionData <- data.frame("Seg" = obs_cov_sample$Seg,
														"groupsize" = obs_cov_sample$size,
														"distance" = obs_cov_sample$distance)
head(sharkDetectionData)

sharkSiteData <- data.frame("Seg" = obs_cov_sample$Seg,
											 "depth" = obs_cov_sample$depth)
head(sharkSiteData)

shark_dfunc <- Rdistance::dfuncEstim(
	formula = formula,
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE,
	control = RdistanceControls(maxIter = 1000)
)

plot(shark_dfunc)
```


```{r fig.width=10}
compare_loi_vrais(tableau = obs_cov_sample,
									formula = "distance ~ depth + distCoast + slopeP")
```

