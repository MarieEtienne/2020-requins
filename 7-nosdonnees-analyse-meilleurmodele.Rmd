---
title: "Sélection des meilleurs modèles"
subtitle: "Fonction de détection et dsm"
output:
  html_document:
    highlight: zenburn
    number_sections: yes
    theme: yeti
    toc: yes
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
rm(list=ls())

knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	error = TRUE
)

# Packages
library(dplyr)				# tidyverse
library(foreign)			# read.dbf
library(DT)						# interactive HTML datatables
library(data.table)

## Graphes packages
library(ggplot2) ; ggplot2::theme_set(theme_light())
library(ggmap)

## Packages calcul
library(Distance)
library(dsm)
```


------------------------------------

Importation des données

```{r import_donnees}
load("../data/effort_output.RData")
# effort_ouput : Effort data divided in multiple sub-data differing by their scale of study.

load("../data/list_prepare_obs_by_sp.RData")
# list_prepare_obs_by_sp : observation data divided in multiple sub-data differing by their scale of study.

load("../data/predata_output.RData")
# predata_output : A grid of 2km cells size with different covariable associated around the observation.

gridata <- read.dbf("../data/SPEE_CAPECET_Grid2km_modified.dbf")
# gridata : equivalent to predata from predata_output but with a extended surface
```

Transformation des données

```{r}
# Jointure
distdata <- dplyr::left_join(list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata, 
																	 cov_segment <- predata_output$segdata,
																	 by = "Seg")

# Réarrangement des colonnes
distdata <- distdata[, c(3, 5:11, 1:2, 14:31)]
colnames(distdata)[1] = "Transect.Label"
colnames(distdata)[2] = "Seg"
colnames(distdata)[3] = "Sample.Label"

distdata$seaState = as.integer(distdata$seaState)
distdata$observerId<-as.integer(distdata$observerId)

# Affichages
head(distdata)
```

```{r}
obsdata <- list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata
segdata <- effort_output$segdata
```

# Fonction de détection
On a sélectionné la meilleure fonction de détection avec le script 6, pour gagner du temps on choisit la meilleure directement ici : `detfc.null.hr`.
```{r}
detfc.null.hr <- Distance::ds(
						distdata,
						max(distdata$distance),
						formula = ~1,
						key = "hr")
```

# Fonction de densité
## dsm pour $availability = 1$
```{r}
dsm_av1 <- dsm(
				formula = count ~ s(SST_4w_mea) + s(X, Y) + s(CHL_4w_mea),
				ddf.obj =  detfc.null.hr,
				segment.data = segdata,
				observation.data = obsdata,
				method = 'REML',
				family = tw(),
				engine = 'gam',
				gamma = 1.4,
				availability = 1)
```

## dsm pour $availability = 0.41$
```{r}
dsm_av0.41 <- dsm(
				formula = count ~ s(SST_4w_mea) + s(X, Y) + s(CHL_4w_mea),
				ddf.obj =  detfc.null.hr,
				segment.data = segdata,
				observation.data = obsdata,
				method = 'REML',
				family = tw(),
				engine = 'gam',
				gamma = 1.4,
				availability = 0.41)
```

## dsm pour `availability` dépendante de on-shelf et off-shelf
On note "on-shelf" quand la profondeur est inférieure à 150m, et "off-shelf" si la profondeur est supérieure à 150m.

$$availability_{off shelf}=0,1357617$$

$$availability_{on shelf}=0,6332016$$
```{r}
distdata$availability = NA
for (i in 1:nrow(distdata)) {
	if (distdata$depth[i] <= 150) {
		distdata$availability[i] = 0.6332016
	} else{
		distdata$availability[i] = 0.1357617
	}
}
availability <- distdata$availability
```


```{r}
dsm_avshelf <- dsm(
				formula = count ~ s(SST_4w_mea) + s(X, Y) + s(CHL_4w_mea),
				ddf.obj =  detfc.null.hr,
				segment.data = segdata,
				observation.data = obsdata,
				method = 'REML',
				family = tw(),
				engine = 'gam',
				gamma = 1.4,
				availability = availability)
```

# Prédiction de l'abondance
```{r}
dsm_av1.pred <- predict(dsm_av1, predata_output$predata, predata_output$predata$Area)
dsm_av0.41.pred <- predict(dsm_av0.41, predata_output$predata, predata_output$predata$Area)
dsm_avshelf.pred <- predict(dsm_avshelf, predata_output$predata, predata_output$predata$Area)
```


## Comparaison des résultats selon la valeur de disponibilité
```{r echo=FALSE}
print(paste("Avec availaibility = 1, on estime qu'il y a", round(sum(dsm_av1.pred), 1), "requins au total dans la zone."))

print(paste("Avec availaibility = 0.41, on estime qu'il y a", round(sum(dsm_av0.41.pred), 1), "requins au total dans la zone."))

print(paste("Avec availaibility selon on/off shelf, on estime qu'il y a", round(sum(dsm_avshelf.pred), 1), "requins au total dans la zone."))
```


## Visualisation
```{r}
plot_pred_by_term(dsm_av1, data = predata_output$segdata, location_cov=c("X","Y"))
```


```{r}
data_occ <- list_prepare_obs_by_sp$PRIGLA_obs_output$distdata %>% filter(detected == 1)
segdata <- effort_output$segdata

# Emplacement
sbbox <- make_bbox(lon = c(min(data_occ$longitude), max(data_occ$longitude)),
									 lat = c(min(data_occ$latitude), max(data_occ$latitude)),
									 f = 1)

# Création de la carte vide
zone_obs <- get_map(location = sbbox,
										zoom = 8,
										maptype =  "terrain")

zone_obs_map = ggmap(zone_obs) + theme_void()
```


```{r}
# Carte avec les points
zone_obs_map +
	geom_path(
		data = segdata,
		mapping = aes(x = longitude, y = latitude, group = Transect.Label),
		size = 0.3,
		colour = alpha("black", 0.2)
	) +
	geom_point(data = data_occ,
						 aes(x = longitude,
						 		y = latitude,
						 		col = session)) +
	theme_void() +
	scale_color_manual(values = wesanderson::wes_palette("BottleRocket1", n = 4))
```

