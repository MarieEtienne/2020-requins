---
title: "Analysis of PRIGLA data of SPEE campaign"
author: "Mathieu Genu & Matthieu Authier"
date: "04/11/2020"
output: github_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.retina = 3)
library(tidyverse)
library(sf)
library(here)
library(foreign) 
library(lubridate)
library(ggmap)
library(Rdistance)
library(cowplot)
```

```{r load data, echo = T}
load(file.path(here::here(), "data/effort_output.RData"))
load(file.path(here::here(), "data/list_prepare_obs_by_sp.RData"))
load(file.path(here::here(), "data/predata_output.RData"))
load(file.path(here::here(), "data/species_info.RData"))
gridata <- read.dbf(file.path(here::here(), "data/SPEE_CAPECET_Grid2km_modified.dbf"))
```


# Study area

Data come from the SPEE campaign that occured in `r year(effort_output$segdata$date) %>% unique()` from `r effort_output$segdata$date %>% min()` to the `r effort_output$segdata$date %>% max()`.  

The campaign took place in the Atlantic Ocean. 

```{r study_area, echo = F, fig.cap="Figure 1 : SPEE campaign transect", out.width='100%'}
segdata <- effort_output$segdata
coastline <- st_read(here::here("data/coastline/coastline_simplified.shp"), quiet = T)

segdata %>% 
  ggplot() +
  geom_sf(data = coastline) +
  coord_sf(xlim = c(-3.5,0), ylim = c(45,47)) +
  geom_path(data = segdata,
            mapping = aes(x = longitude, y = latitude, group = Transect.Label), 
            size = 1,
            colour = alpha("black", 0.5)) +
  facet_wrap(session~., labeller = label_both) +
  theme_light()

##session : une sortie où il y a plusieurs transects
```



We focus on one species the blue shark (Prionace glauca).

![blue_shark](data/img/Prionace_glauca.jpg)


The R environment gather different data :

* list_prepare_obs_by_sp : observation data divided in multiple sub-data differing by their scale of study.<br>
```{r str of observation data, echo = F}
str(list_prepare_obs_by_sp, max.level = 2)
```

distdata : a table for conventional distance sampling analyses as implemented in package *Distance*. The detections in this table can be mapped onto the study area and survey design :

```{r}
a <- ggplot() +
  geom_sf(data = coastline) +
  coord_sf(xlim = c(-3.5,0), ylim = c(45,47)) +
  geom_path(data = segdata,
            mapping = aes(x = longitude, y = latitude, group = Transect.Label, col = trans), 
            size = 1,
            colour = alpha("black", 0.5)
            ) +
  geom_point(data = list_prepare_obs_by_sp$PRIGLA_obs_output$distdata %>% 
               filter(detected == 1),
             aes(x = longitude, y = latitude)
             ) +
  facet_wrap(session~., labeller = label_both) +
  theme_light()

b <- ggplot() +
  geom_sf(data = coastline) +
  coord_sf(xlim = c(-3.5,0), ylim = c(45,47)) +
  geom_path(data = segdata,
            mapping = aes(x = longitude, y = latitude, group = Transect.Label), 
            size = 1,
            colour = alpha("black", 0.5)
            ) +
  geom_point(data = list_prepare_obs_by_sp$PRIGLA_obs_output$distdata %>% 
               filter(detected == 1),
             aes(x = longitude, y = latitude, col = session)
             ) +
  theme_light()

library(cowplot)
plot_grid(a,b)
```

CARTE D'OCCURENCE POUR LES 4 SESSIONS COMBINEES
```{r}
data_occ <- list_prepare_obs_by_sp$PRIGLA_obs_output$distdata %>%
	filter(detected == 1)

# Emplacement
sbbox <- make_bbox(lon = c(min(data_occ$longitude), max(data_occ$longitude)),
									 lat = c(min(data_occ$latitude), max(data_occ$latitude)),
									 f = 1)

# Création de la carte vide
zone_obs <- get_map(location = sbbox,
										zoom = 8,
										maptype =  "terrain")

zone_obs_map = ggmap(zone_obs) + theme_void()

zone_obs_map + geom_point(data = data_occ,
														aes(x = longitude,
																y = latitude,
																col = session))
```


obsdata : a table with the detected individuals, and their perpendicular distance to the transect (in km).

```{r obsdata}
##Plot avec répartition des classes de distance différentes
c <- list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata %>% 
  ggplot(aes(x = distance)) +
  geom_histogram(breaks = seq(0, 0.4, 0.05)) +
  theme_bw()

d <- list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata %>% 
  ggplot(aes(x = distance)) +
  geom_histogram(bins = 10) +
  theme_bw()

plot_grid(c,d)
```

countdata_leg : a table with detections aggregated at the level of legs (ie bout of transect for which observations conditions, e.g. Beaufort sea state; were homogeneous during sampling).

countdata_seg : a table with detections aggregated at the level of segments (ie bout of transect for which observations conditions, e.g. Beaufort sea state; were homogeneous during sampling and of similar length). But see also the object effort_ouput below.<br>

* effort_ouput : Effort data divided in multiple sub-data differing by their scale of study.<br>

legdata : a table with the effort (legs). Observations in the table countdata_leg above can be joined to this effort with the 'Sample.Label' column.

segdata : a table with the effort (legs). Observations in the table countdata_seg above can be joined to this effort with the 'Seg' column. This table also includes several covariates for modelling (e.g. generalized linear model, kriging). The columns 'X, Y' include projected coordinates (in Lambert 93) and can be used for geostatistical modelling.

* predata_output : A grid of 2km cells size with different covariable associated around the observation.<br>
```{r str of predata_output, echo = F, fig.retina=3}
str(list_prepare_obs_by_sp, max.level = 2)
ggplot() +
  geom_tile(data = predata_output$predata, 
            aes(x = longitude, y = latitude),
            colour = "black", 
            fill = alpha("white", 0)) +
  geom_sf(data = coastline) +
  theme_light()
```

* gridata : equivalent to predata from predata_output but with a extended surface
```{r gridata, fig.retina=3, echo = F}
ggplot() +
  geom_tile(data = gridata, 
            aes(x = lon, y = lat),
            colour = "black", 
            fill = alpha("white", 0)) +
  geom_sf(data = coastline) +
  theme_light()
  
```


Si on superpose les deux espaces :
Question : prédiction à étendre sur cette nouvelle surface ou pas?
```{r}
str(list_prepare_obs_by_sp, max.level = 2)
ggplot() +
  geom_tile(data = gridata, 
            aes(x = lon, y = lat),
            colour = "grey", 
            fill = alpha("white", 0)) +
  geom_tile(data = predata_output$predata, 
            aes(x = longitude, y = latitude),
            colour = "black", 
            fill = alpha("white", 0)) +
  geom_sf(data = coastline)  
```


Utiliser le package Rdistance
Représentation graphique des probabilités de détection en fonction de la distance
Calcul sans covariables

Création d'une fonction `compare_loi_vrais` qui prend en arguments le tableau de données et la formula (`distance ~ 1` ou `distance ~ covar1 + covar2`), et renvoie un graphique qui compare les 5 lois de distributions disponibles pour la vraisemblance.
```{r fig.width=10}
library(Rdistance)
compare_loi_vrais <- function(tableau, formula){
data <- list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata[,c(1,3)]

dfunc1 <- dfuncEstim(formula = distance~1, detectionData = data, likelihood = "halfnorm", w.hi = 0.3)

dfunc2 <- dfuncEstim(formula = distance~1, detectionData = data, likelihood = "uniform", w.hi = 0.3)

dfunc3 <- dfuncEstim(formula = distance~1, detectionData = data, likelihood = "hazrate", w.hi = 0.3)

dfunc4 <- dfuncEstim(formula = distance~1, detectionData = data, likelihood = "negexp", w.hi = 0.3)

dfunc5 <- dfuncEstim(formula = distance~1, detectionData = data, likelihood = "Gamma", w.hi = 0.3)
}

par(mfrow=c(2,3))
plot(dfunc1)
plot(dfunc2)
plot(dfunc3)
plot(dfunc4)
plot(dfunc5)
```

Sans covariables, on obtient ceci :

```{r fig.width=10}
compare_loi_vrais(tableau = list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata[,c(1,3)],
									formula = "distance ~ 1")
```

## Fonction de détection : ajout des covariables

```{r, echo = TRUE}
head(list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata[,c(3,5,6)])
```

Dans obsdata, on a aussi les segments de transect `Seg` et le `Sample.Label`. On pourra donc lier les données obs et les données covariables sur l'une de ces variables.
```{r, echo = TRUE}
cov_segment <- predata_output$segdata
dim(cov_segment)
head(cov_segment[, c(3,5,4)])
```

On va alors pouvoir récupérer plusieurs covariables intéressantes :

```{r}
cov_segment[1:3,15:23] %>% as_tibble()
```

* La profondeur `depth`
* La distance par rapport à la côte `distCoast`
* ?? `dist200`
* La pente `slopeP`
* ?? `CHL_4w_mea` `CHL_4w_sd`  `SST_4w_mea` `SST_4w_sd`  `POC_4w_mea`

### Manipulation des données : création d'une table avec les observations et les covariables

**Quelle est la clé unique de cov_segment ? Seg ou Sample.Label ?**

```{r, echo = TRUE}
nrow(cov_segment)
nrow(distinct(cov_segment, Seg))
nrow(distinct(cov_segment, Sample.Label))
```

Il s'agit de Seg. On va donc joindre sur Seg. On obtient le tableau suivant

```{r}
# Jointure
obs_cov_sample <- dplyr::left_join(list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata, cov_segment, by = "Seg")

# Réarrangement des colonnes
obs_cov_sample <- obs_cov_sample[, c(3, 5:11, 1:2, 14:31)]
colnames(obs_cov_sample)[1] = "Transect.Label"
colnames(obs_cov_sample)[2] = "Seg"

# Affichages
DT::datatable(obs_cov_sample)
```

# Fonctions de détection avec covariables
## Fonction de détection en fonction de l'état de la mer

```{r echo=TRUE}
# Initialisation
formula <- "distance ~ seaState"
sharkDetectionData <- data.frame("Seg" = obs_cov_sample$Seg,
														"groupsize" = obs_cov_sample$size,
														"distance" = obs_cov_sample$distance)
head(sharkDetectionData)

sharkSiteData <- data.frame("Seg" = obs_cov_sample$Seg,
											 "seaState" = as.factor(obs_cov_sample$seaState))
head(sharkSiteData)

# Estimation de la fonction de détection
shark_dfunc <- Rdistance::dfuncEstim(
	formula = formula,
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)

# Affichage
plot(shark_dfunc,
		 newdata = data.frame(seaState = levels(sharkSiteData$seaState)))
```

## Fonction de détection en fonction de la profondeur, la distance par rapport à la côte et la pente
```{r}
# sharkDetectionData
sharkDetectionData <- data.frame(
	"Seg" = obs_cov_sample$Seg,
	"groupsize" = obs_cov_sample$size,
	"distance" = obs_cov_sample$distance
)
head(sharkDetectionData)

#sharkSiteData
sharkSiteData <- data.frame(
	"Seg" = obs_cov_sample$Seg,
	"depth" = obs_cov_sample$depth,
	"distCoast" = obs_cov_sample$distCoast,
	"slopeP" = obs_cov_sample$slopeP
)

# Discrétisation des covariables
sharkSiteData$depth = factor(cut(
	x = sharkSiteData$depth,
	breaks = 3,
	labels = c("Faible", "Moyen", "Eleve")
))
sharkSiteData$distCoast = factor(cut(
	x = sharkSiteData$distCoast,
	breaks = 3,
	labels = c("Faible", "Moyen", "Eleve")
))
sharkSiteData$slopeP = factor(cut(
	x = sharkSiteData$slopeP,
	breaks = 3,
	labels = c("Faible", "Moyen", "Eleve")
))
# Affichage
head(sharkSiteData)
```


### depth (profondeur)
```{r}
shark_dfunc_p <- Rdistance::dfuncEstim(
	formula = "distance ~ depth",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_p
```

### distCoast
```{r}
shark_dfunc_d <- Rdistance::dfuncEstim(
	formula = "distance ~ distCoast",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_d
```

### slopeP
```{r}
shark_dfunc_s <- Rdistance::dfuncEstim(
	formula = "distance ~ slopeP",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_s
```

### depth (p) + distCoast
```{r}
shark_dfunc_p_d <- Rdistance::dfuncEstim(
	formula = "distance ~ depth + distCoast",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_p_d
```

### depth (p) + slopeP
```{r}
shark_dfunc_p_s <- Rdistance::dfuncEstim(
	formula = "distance ~ depth + slopeP",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_p_s
```

### distCoast + slopeP
```{r}
shark_dfunc_d_s<- Rdistance::dfuncEstim(
	formula = "distance ~ distCoast + slopeP",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_d_s
```

### depth (p) + distCoast + slopeP
```{r}
shark_dfunc_p_d_s<- Rdistance::dfuncEstim(
	formula = "distance ~ depth + distCoast + slopeP",
	detectionData = sharkDetectionData,
	siteData = sharkSiteData,
	likelihood = "halfnorm",
	w.hi = 0.3,
	pointSurvey = FALSE
)
shark_dfunc_p_d_s
```

### Resultats graphiques

**Résultats **

```{r fig.height = 15, fig.width=10}
plot_dfunc_lea <- function(dfunc_res, newdata, titre = "") {
	plot(
		dfunc_res,
		newdata = newdata,
		nbins = 15,
		col = "#BDD9D6",
		border = 0,
		vertLines = FALSE,
		main = titre
	)
}

par(mfrow = c(3, 2))

### depth (profondeur)
plot_dfunc_lea(
	dfunc_res = shark_dfunc_p,
	newdata = data.frame(depth = levels(sharkSiteData$depth)),
	titre = "depth"
)

### distCoast
plot_dfunc_lea(
	dfunc_res = shark_dfunc_d,
	newdata = data.frame(distCoast = levels(sharkSiteData$distCoast)),
	titre = "distCoast"
)

### slopeP
plot_dfunc_lea(
	dfunc_res = shark_dfunc_s,
	newdata = data.frame(slopeP = levels(sharkSiteData$slopeP)),
	titre = "slopeP"
)

### depth (p) + distCoast
plot_dfunc_lea(
	dfunc_res = shark_dfunc_p_d,
	newdata = expand.grid(
		depth = levels(sharkSiteData$depth),
		distCoast = levels(sharkSiteData$distCoast)
	),
	titre = "depth + distCoast"
)

### depth (p) + slopeP
plot_dfunc_lea(
	dfunc_res = shark_dfunc_p_s,
	newdata = expand.grid(
		depth = levels(sharkSiteData$depth),
		slopeP = levels(sharkSiteData$slopeP)
	),
	titre = "depth  + slopeP"
)

### distCoast + slopeP
plot_dfunc_lea(
	dfunc_res = shark_dfunc_d_s,
	newdata = expand.grid(
		distCoast = levels(sharkSiteData$distCoast),
		slopeP = levels(sharkSiteData$slopeP)
	),
	titre = "distCoast + slopeP"
)
```


```{r fig.height = 8, fig.width=10}
plot_dfunc_lea(
	dfunc_res = shark_dfunc_p_d_s,
	newdata = expand.grid(
		depth = levels(sharkSiteData$depth),
		distCoast = levels(sharkSiteData$distCoast),
		slopeP = levels(sharkSiteData$slopeP)
	),
	titre = "depth + distCoast + slopeP"
)
```


################################
PACKAGE DISTANCE ET DSM
################################


Transformation des données

```{r}
# Jointure
distdata <- dplyr::left_join(list_prepare_obs_by_sp$PRIGLA_obs_output$obsdata, 
																	 cov_segment <- predata_output$segdata,
																	 by = "Seg")

# Réarrangement des colonnes
distdata <- distdata[, c(3, 5:11, 1:2, 14:31)]
colnames(distdata)[1] = "Transect.Label"
colnames(distdata)[2] = "Seg"
colnames(distdata)[3] = "Sample.Label"
distdata$observerId <- as.integer(distdata$observerId)

# Affichages
head(distdata)
```

[1] "segdata"
[1] "longitude"      "latitude"       "x"              "y"              "Effort"        
[6] "Transect.Label" "Sample.Label"   "depth"         
[1] "obsdata"
[1] "object"       "Sample.Label" "size"         "distance"     "Effort"      

```{r}
segdata <-
	data.frame(
		"longitude" = distdata$longitude,
		"latitude" = distdata$latitude,
		"X" = distdata$X,
		"Y" = distdata$Y,
		"Effort" = distdata$Effort,
		"Transect.Label" = distdata$Transect.Label,
		"Sample.Label" = distdata$Sample.Label,
		"depth" = distdata$depth,
		"seaState" = distdata$seaState,
		"observerId" = as.integer(distdata$observerId)
	)
head(segdata)

obsdata <-
	data.frame(
		"object" = distdata$object,
		"Sample.Label" = distdata$Sample.Label,
		"size" = distdata$size,
		"distance" = distdata$distance,
		"Effort" = distdata$Effort
	)
head(obsdata)
```


# Sans aucune covariables

## Fonction de détection
```{r}
detfc.null <- Distance::ds(distdata,
							 max(distdata$distance),
							 key = "hr",
							 adjustment = NULL)
```


```{r}
summary(detfc.null)
par(mfrow=c(1,2))
plot(detfc.null, showpoints=FALSE, pl.den=0, lwd=2)
ddf.gof(detfc.null$ddf)
```

## Fonction de densité

```{r}
library(dsm)
dsm.xy <- dsm(count ~ s(X, Y), 
							detfc.null,
							segdata,
							obsdata,
							method = "REML")
summary(dsm.xy)
```

```{r}
dsm.null <- vis.gam(
	dsm.xy,
	plot.type = "contour",
	view = c("X", "Y"),
	asp = 1,
	type = "response",
	contour.col = "black",
	n.grid = 100
)
```




##################
FONCTION DE DETECTION AVEC COVARIABLES DEPTH,SEASTATE,OBSERVERID
```{r}
detfc.cov <- Distance::ds(distdata,
							 max(distdata$distance),
							 formula = ~ seaState + observerId,
							 key = "hr",
							 adjustment = NULL)
```
```{r}
summary(detfc.cov)
par(mfrow=c(1,2))
plot(detfc.cov, showpoints=FALSE, pl.den=0, lwd=2)
ddf.gof(detfc.cov$ddf)

```


JUSTE POUR COMPRENDRE LE TRUC MAIS NO NEED
```{r}
newobsdata <- obsdata %>% group_by(Sample.Label) %>% summarise(count = sum(size))
```


```{r}
library(dsm)
dsm.cov <- dsm(count ~ s(X, Y), 
							detfc.cov,
							segdata,
							obsdata,
							method = "REML")
summary(dsm.cov)


newobsdata <- obsdata %>% group_by(Sample.Label) %>% summarise(count= sum(size))
```

```{r}
plot.dsm.cov <- vis.gam(
	dsm.cov,
	plot.type = "contour",
	view = c("X", "Y"),
	asp = 1,
	type = "response",
	contour.col = "black",
	n.grid = 100,
	main = "seastate et obsID"
)
```



```{r}
par(mfrow=c(1,2))

vis.gam(
	dsm.xy,
	plot.type = "contour",
	view = c("X", "Y"),
	asp = 1,
	type = "response",
	contour.col = "black",
	n.grid = 100,
	main = "null"
)

 vis.gam(
	dsm.cov,
	plot.type = "contour",
	view = c("X", "Y"),
	asp = 1,
	type = "response",
	contour.col = "black",
	n.grid = 100,
	main = "seastate et obsID"
)


```

```{r}
library(zoib)
zoib()
```

